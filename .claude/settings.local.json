{
  "permissions": {
    "allow": [
      "Bash(flutter analyze:*)",
      "Bash(findstr:*)",
      "Bash(dart fix:*)",
      "Bash(powershell -Command:*)",
      "Bash(dart analyze:*)",
      "Bash(flutter clean:*)",
      "Bash(flutter pub get:*)",
      "Bash(start ms-settings:developers)",
      "Bash(flutter build:*)",
      "Bash(where:*)",
      "Bash(flutter doctor:*)",
      "Bash(timeout:*)",
      "Bash(taskkill:*)",
      "Bash(flutter run:*)",
      "Bash(git stash push:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(git push:*)",
      "WebFetch(domain:api.spendex.in)",
      "Bash(wc:*)",
      "Bash(flutter pub:*)",
      "Bash(dir:*)",
      "WebSearch",
      "Bash(\"D:\\\\fluter_projects\\\\spendex\\\\lib\\\\features\\\\transactions\\\\presentation\\\\widgets\\\\transaction_search_delegate.dart\" << 'EOF'\n\n/// Voice search dialog widget\nclass _VoiceSearchDialog extends StatefulWidget {\n  const _VoiceSearchDialog\\({\n    required this.onResult,\n    required this.speech,\n  }\\);\n\n  final ValueChanged<String> onResult;\n  final SpeechToText speech;\n\n  @override\n  State<_VoiceSearchDialog> createState\\(\\) => _VoiceSearchDialogState\\(\\);\n}\n\nclass _VoiceSearchDialogState extends State<_VoiceSearchDialog> {\n  String _recognizedText = '';\n  bool _isListening = false;\n\n  @override\n  void initState\\(\\) {\n    super.initState\\(\\);\n    _startListening\\(\\);\n  }\n\n  @override\n  void dispose\\(\\) {\n    if \\(widget.speech.isListening\\) {\n      widget.speech.stop\\(\\);\n    }\n    super.dispose\\(\\);\n  }\n\n  Future<void> _startListening\\(\\) async {\n    setState\\(\\(\\) {\n      _isListening = true;\n    }\\);\n\n    try {\n      await widget.speech.listen\\(\n        onResult: \\(SpeechRecognitionResult result\\) {\n          setState\\(\\(\\) {\n            _recognizedText = result.recognizedWords;\n          }\\);\n\n          if \\(result.finalResult\\) {\n            widget.onResult\\(_recognizedText\\);\n          }\n        },\n        listenFor: const Duration\\(seconds: 10\\),\n        pauseFor: const Duration\\(seconds: 2\\),\n        partialResults: true,\n        listenMode: ListenMode.confirmation,\n      \\);\n    } catch \\(e\\) {\n      widget.onResult\\(''\\);\n    }\n  }\n\n  void _stopListening\\(\\) {\n    if \\(widget.speech.isListening\\) {\n      widget.speech.stop\\(\\);\n    }\n    widget.onResult\\(_recognizedText\\);\n  }\n\n  @override\n  Widget build\\(BuildContext context\\) {\n    final isDark = Theme.of\\(context\\).brightness == Brightness.dark;\n\n    return AlertDialog\\(\n      backgroundColor: isDark ? SpendexColors.darkCard : SpendexColors.lightCard,\n      shape: RoundedRectangleBorder\\(\n        borderRadius: BorderRadius.circular\\(16\\),\n      \\),\n      title: Row\\(\n        children: [\n          const Icon\\(\n            Iconsax.microphone_2,\n            color: SpendexColors.primary,\n          \\),\n          const SizedBox\\(width: 12\\),\n          Text\\(\n            'Voice Search',\n            style: SpendexTheme.headlineMedium.copyWith\\(\n              color: isDark\n                  ? SpendexColors.darkTextPrimary\n                  : SpendexColors.lightTextPrimary,\n            \\),\n          \\),\n        ],\n      \\),\n      content: Column\\(\n        mainAxisSize: MainAxisSize.min,\n        children: [\n          const SizedBox\\(height: 16\\),\n          Icon\\(\n            Iconsax.microphone_2,\n            size: 48,\n            color: _isListening ? SpendexColors.primary : SpendexColors.expense,\n          \\),\n          const SizedBox\\(height: 24\\),\n          Text\\(\n            _isListening ? 'Listening...' : 'Processing...',\n            style: SpendexTheme.titleMedium.copyWith\\(\n              color: isDark\n                  ? SpendexColors.darkTextPrimary\n                  : SpendexColors.lightTextPrimary,\n            \\),\n          \\),\n          const SizedBox\\(height: 16\\),\n          Container\\(\n            padding: const EdgeInsets.all\\(12\\),\n            decoration: BoxDecoration\\(\n              color: isDark\n                  ? SpendexColors.darkBackground\n                  : SpendexColors.lightBackground,\n              borderRadius: BorderRadius.circular\\(12\\),\n            \\),\n            child: Text\\(\n              _recognizedText.isEmpty ? 'Say something...' : _recognizedText,\n              style: SpendexTheme.bodyMedium.copyWith\\(\n                color: isDark\n                    ? SpendexColors.darkTextSecondary\n                    : SpendexColors.lightTextSecondary,\n              \\),\n              textAlign: TextAlign.center,\n            \\),\n          \\),\n        ],\n      \\),\n      actions: [\n        TextButton\\(\n          onPressed: \\(\\) {\n            widget.speech.cancel\\(\\);\n            widget.onResult\\(''\\);\n          },\n          child: Text\\(\n            'Cancel',\n            style: SpendexTheme.titleMedium.copyWith\\(\n              color: isDark\n                  ? SpendexColors.darkTextSecondary\n                  : SpendexColors.lightTextSecondary,\n            \\),\n          \\),\n        \\),\n        FilledButton\\(\n          onPressed: _stopListening,\n          child: const Text\\('Done'\\),\n        \\),\n      ],\n    \\);\n  }\n}\nEOF)",
      "Bash(test:*)",
      "Bash(\"D:/fluter_projects/spendex/lib/features/goals/domain/repositories/goals_repository.dart\" << 'EOF'\nimport 'package:dartz/dartz.dart';\n\nimport '../../../../core/errors/failures.dart';\nimport '../../data/models/goal_model.dart';\n\n/// Repository interface for Goals feature.\n///\n/// Defines all operations for managing savings goals including CRUD operations,\n/// contributions, and summary statistics.\nabstract class GoalsRepository {\n  /// Retrieves all goals for the current user.\n  Future<Either<Failure, List<GoalModel>>> getGoals\\(\\);\n\n  /// Retrieves summary statistics for all goals.\n  Future<Either<Failure, GoalsSummary>> getGoalsSummary\\(\\);\n\n  /// Retrieves a specific goal by ID.\n  Future<Either<Failure, GoalModel>> getGoalById\\(String id\\);\n\n  /// Creates a new savings goal.\n  Future<Either<Failure, GoalModel>> createGoal\\(CreateGoalRequest request\\);\n\n  /// Updates an existing goal.\n  Future<Either<Failure, GoalModel>> updateGoal\\(\n    String id,\n    CreateGoalRequest request,\n  \\);\n\n  /// Deletes a goal permanently.\n  Future<Either<Failure, void>> deleteGoal\\(String id\\);\n\n  /// Adds a contribution to a goal.\n  Future<Either<Failure, GoalModel>> addContribution\\(\n    String id,\n    int amount,\n    String? notes,\n  \\);\n}\nEOF)",
      "Bash(\"D:/fluter_projects/spendex/lib/features/insights/data/models/insight_model.dart\" << 'EOF'\nimport 'package:equatable/equatable.dart';\n\n/// Insight Type Enum\nenum InsightType {\n  spendingPattern\\('spending_pattern'\\),\n  savingsOpportunity\\('savings_opportunity'\\),\n  billPrediction\\('bill_prediction'\\),\n  anomalyDetection\\('anomaly_detection'\\),\n  budgetRecommendation\\('budget_recommendation'\\),\n  goalAchievability\\('goal_achievability'\\),\n  loanInsight\\('loan_insight'\\),\n  categoryTrend\\('category_trend'\\),\n  merchantAnalysis\\('merchant_analysis'\\),\n  cashFlowForecast\\('cash_flow_forecast'\\);\n\n  const InsightType\\(this.value\\);\n  final String value;\n\n  static InsightType fromString\\(String value\\) {\n    return InsightType.values.firstWhere\\(\n      \\(type\\) => type.value == value,\n      orElse: \\(\\) => InsightType.spendingPattern,\n    \\);\n  }\n\n  String get label {\n    switch \\(this\\) {\n      case InsightType.spendingPattern:\n        return 'Spending Pattern';\n      case InsightType.savingsOpportunity:\n        return 'Savings Opportunity';\n      case InsightType.billPrediction:\n        return 'Bill Prediction';\n      case InsightType.anomalyDetection:\n        return 'Anomaly Detection';\n      case InsightType.budgetRecommendation:\n        return 'Budget Recommendation';\n      case InsightType.goalAchievability:\n        return 'Goal Achievability';\n      case InsightType.loanInsight:\n        return 'Loan Insight';\n      case InsightType.categoryTrend:\n        return 'Category Trend';\n      case InsightType.merchantAnalysis:\n        return 'Merchant Analysis';\n      case InsightType.cashFlowForecast:\n        return 'Cash Flow Forecast';\n    }\n  }\n}\n\n/// Insight Priority Enum\nenum InsightPriority {\n  high\\('high'\\),\n  medium\\('medium'\\),\n  low\\('low'\\);\n\n  const InsightPriority\\(this.value\\);\n  final String value;\n\n  static InsightPriority fromString\\(String value\\) {\n    return InsightPriority.values.firstWhere\\(\n      \\(priority\\) => priority.value == value,\n      orElse: \\(\\) => InsightPriority.medium,\n    \\);\n  }\n\n  String get label {\n    switch \\(this\\) {\n      case InsightPriority.high:\n        return 'High';\n      case InsightPriority.medium:\n        return 'Medium';\n      case InsightPriority.low:\n        return 'Low';\n    }\n  }\n}\n\n/// Insight Action Type Enum\nenum InsightActionType {\n  viewTransactions\\('view_transactions'\\),\n  setBudget\\('set_budget'\\),\n  setGoal\\('set_goal'\\),\n  viewCategory\\('view_category'\\),\n  viewMerchant\\('view_merchant'\\),\n  viewAccount\\('view_account'\\),\n  viewLoan\\('view_loan'\\),\n  none\\('none'\\);\n\n  const InsightActionType\\(this.value\\);\n  final String value;\n\n  static InsightActionType fromString\\(String value\\) {\n    return InsightActionType.values.firstWhere\\(\n      \\(type\\) => type.value == value,\n      orElse: \\(\\) => InsightActionType.none,\n    \\);\n  }\n\n  String get label {\n    switch \\(this\\) {\n      case InsightActionType.viewTransactions:\n        return 'View Transactions';\n      case InsightActionType.setBudget:\n        return 'Set Budget';\n      case InsightActionType.setGoal:\n        return 'Set Goal';\n      case InsightActionType.viewCategory:\n        return 'View Category';\n      case InsightActionType.viewMerchant:\n        return 'View Merchant';\n      case InsightActionType.viewAccount:\n        return 'View Account';\n      case InsightActionType.viewLoan:\n        return 'View Loan';\n      case InsightActionType.none:\n        return '';\n    }\n  }\n}\n\n/// AI Insight Model\nclass InsightModel extends Equatable {\n  const InsightModel\\({\n    required this.id,\n    required this.type,\n    required this.category,\n    required this.title,\n    required this.description,\n    required this.priority,\n    required this.actionType,\n    required this.createdAt,\n    this.actionData,\n    this.validUntil,\n    this.isRead = false,\n    this.isDismissed = false,\n    this.metadata,\n  }\\);\n\n  factory InsightModel.fromJson\\(Map<String, dynamic> json\\) {\n    return InsightModel\\(\n      id: json['id'] as String,\n      type: InsightType.fromString\\(json['type'] as String\\),\n      category: json['category'] as String,\n      title: json['title'] as String,\n      description: json['description'] as String,\n      priority: InsightPriority.fromString\\(json['priority'] as String\\),\n      actionType: InsightActionType.fromString\\(\n        json['actionType'] as String? ?? 'none',\n      \\),\n      actionData: json['actionData'] as Map<String, dynamic>?,\n      validUntil: json['validUntil'] != null\n          ? DateTime.parse\\(json['validUntil'] as String\\)\n          : null,\n      isRead: json['isRead'] as bool? ?? false,\n      isDismissed: json['isDismissed'] as bool? ?? false,\n      metadata: json['metadata'] as Map<String, dynamic>?,\n      createdAt: DateTime.parse\\(json['createdAt'] as String\\),\n    \\);\n  }\n\n  final String id;\n  final InsightType type;\n  final String category;\n  final String title;\n  final String description;\n  final InsightPriority priority;\n  final InsightActionType actionType;\n  final Map<String, dynamic>? actionData;\n  final DateTime? validUntil;\n  final bool isRead;\n  final bool isDismissed;\n  final Map<String, dynamic>? metadata;\n  final DateTime createdAt;\n\n  Map<String, dynamic> toJson\\(\\) {\n    return {\n      'id': id,\n      'type': type.value,\n      'category': category,\n      'title': title,\n      'description': description,\n      'priority': priority.value,\n      'actionType': actionType.value,\n      if \\(actionData != null\\) 'actionData': actionData,\n      if \\(validUntil != null\\) 'validUntil': validUntil!.toIso8601String\\(\\),\n      'isRead': isRead,\n      'isDismissed': isDismissed,\n      if \\(metadata != null\\) 'metadata': metadata,\n      'createdAt': createdAt.toIso8601String\\(\\),\n    };\n  }\n\n  InsightModel copyWith\\({\n    String? id,\n    InsightType? type,\n    String? category,\n    String? title,\n    String? description,\n    InsightPriority? priority,\n    InsightActionType? actionType,\n    Map<String, dynamic>? actionData,\n    DateTime? validUntil,\n    bool? isRead,\n    bool? isDismissed,\n    Map<String, dynamic>? metadata,\n    DateTime? createdAt,\n  }\\) {\n    return InsightModel\\(\n      id: id ?? this.id,\n      type: type ?? this.type,\n      category: category ?? this.category,\n      title: title ?? this.title,\n      description: description ?? this.description,\n      priority: priority ?? this.priority,\n      actionType: actionType ?? this.actionType,\n      actionData: actionData ?? this.actionData,\n      validUntil: validUntil ?? this.validUntil,\n      isRead: isRead ?? this.isRead,\n      isDismissed: isDismissed ?? this.isDismissed,\n      metadata: metadata ?? this.metadata,\n      createdAt: createdAt ?? this.createdAt,\n    \\);\n  }\n\n  /// Check if insight is still valid\n  bool get isValid {\n    if \\(validUntil == null\\) return true;\n    return DateTime.now\\(\\).isBefore\\(validUntil!\\);\n  }\n\n  /// Check if insight is expired\n  bool get isExpired => !isValid;\n\n  /// Check if insight is active \\(not read, not dismissed, still valid\\)\n  bool get isActive => !isRead && !isDismissed && isValid;\n\n  /// Get days remaining until expiration\n  int? get daysRemaining {\n    if \\(validUntil == null\\) return null;\n    return validUntil!.difference\\(DateTime.now\\(\\)\\).inDays;\n  }\n\n  @override\n  List<Object?> get props => [\n        id,\n        type,\n        category,\n        title,\n        description,\n        priority,\n        actionType,\n        actionData,\n        validUntil,\n        isRead,\n        isDismissed,\n        metadata,\n        createdAt,\n      ];\n}\n\n/// Create Insight Request \\(for backend generation trigger\\)\nclass CreateInsightRequest {\n  const CreateInsightRequest\\({\n    this.forceRegenerate = false,\n    this.analysisDepth = 'standard',\n  }\\);\n\n  final bool forceRegenerate;\n  final String analysisDepth; // 'quick', 'standard', 'deep'\n\n  Map<String, dynamic> toJson\\(\\) {\n    return {\n      'forceRegenerate': forceRegenerate,\n      'analysisDepth': analysisDepth,\n    };\n  }\n}\n\n/// Update Insight Request\nclass UpdateInsightRequest {\n  const UpdateInsightRequest\\({\n    this.isRead,\n    this.isDismissed,\n  }\\);\n\n  final bool? isRead;\n  final bool? isDismissed;\n\n  Map<String, dynamic> toJson\\(\\) {\n    return {\n      if \\(isRead != null\\) 'isRead': isRead,\n      if \\(isDismissed != null\\) 'isDismissed': isDismissed,\n    };\n  }\n}\nEOF)"
    ]
  }
}
